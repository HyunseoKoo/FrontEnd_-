/* https://hanamon.kr/nodejs-%EA%B0%9C%EB%85%90-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0/   참고
node.js란? 확장성 있는 네트워크 어플리케이션 개발에 사용되는 소프트웨어 플랫폼(환경)이다.

node.js 사용 이유? 
자바스크립트는 스크립트 언어로, 특정한 프로그램 안에서 동작하는 프로그램이기 때문에 웹 브라우저 프로그램 안에서만 동작한다.
즉, 웹 브라우저(크롬, 사파리, 익스플로러, 파이어폭스 등)가 없으면 사용할 수 없는 프로그램이다.
여기서 Node.js가 나오게된 이유가 된다.
즉, JavaScript를 웹 브라우저에서 독립시킨 것으로 Node.js를 설치하게 되면 터미널프로그램(윈도우의 cmd, 맥의 terminal 등)에서 Node.js를 입력하여 브라우저 없이 바로 실행할 수 있다.

중요한 건, Node.js를 이용하여 서버를 만들 수 있다는 것이다.
중요한 이유는 이전까지 서버-클라이언트 웹사이트를 만들때 웹에서 표시되는 부분은 자바스크립트를 사용하여 만들어야만 했으며,
서버는 Reby, Java 등 다른 언어를 써서 만들었어야 했는데 마침내 [한 가지 언어로 전체 웹 페이지를 만들 수 있게 된 것]이다.

자바스크립트 런타임 ? [런타임]이란 특정 언어로 만든 프로그램을 실행할 수 있는 환경을 뜻한다.

이벤트 기반 => 이벤트가 발생할 때 미리 지정해둔 작업을 수행하는 방식을 의미한다.
즉, 이벤트 기반 시스템에서는 특정 이벤트가 발생할 때 무엇을 할지 미리 등록해두고, 이를 이벤트 리스너에 콜백함수를 등록한다.
이후 이벤트가 발생하면 리스너에 등록해둔 콜백함수를 호출하며, 이벤트가 끝난 후 노드는 다음 이벤트가 발생할 때까지 대기한다.

이벤트 루프 => 여러 이벤트가 동시에 발생했을 때 어떤 순서로 콜백함수를 호출할지를 이벤트 루프가 판단한다.
노드는 이벤트가 종료될 때까지 이벤트 처리를 위한 작업을 반복하므로 루프(loop)라고 부른다.

논 블로킹 I/O?
이벤트 루프를 잘 활용하면 오래 걸리는 작업을 효율적으로 처리할 수 있다.
작업에는 두 가지 종료가 있는데 [동시에 실행될 수 있는 작업]과 [동시에 실행될 수 없는 작업]이다.
특피 파일 시스템 접근, 네트워크를 통한 요청 작업은 입력(Input)/출력(Output)의 일종이며, 이러한 작업을 할 때
노드는 비동기 방식으로 블로킹을 만들지 않게끔(논 블로킹) 처리한다.
[비동기]란 이전 작업이 완료될 때까지 대기하지 않고 동시에 작업을 수행한다.
반대로 [동기]는 이전 작업이 끝나야만 다음 작업을 수행한다.
즉, 함수 호출 시 당장 실행하는 것이 아니라(동기 → 블로킹) 일단 어느 곳에 쌓아 놓고 동시에 요청을 처리하고 (비동기 → 논 브로킹) 요청이 완료된 순서대로 처리(스택이용)한다.

싱글 스레드?
자바스크립트 코드는 동시에 실행될 수 없는데 그 이유는 노드가 싱글 스레드 기반이기 때문이다.
(스레드? 프로스세 내에서 실행되는 흐름의 단위. 프로세스는 스레드를 여러개 생성해 여러 작업을 동시에 처리할 수 있다. 스레드들은 부모 프로세스의 자원을 공유한다.
    같은 주소의 메모리에 접근 가능하므로 데이터를 공유할 수 있다.       // 프로세스? 운영체제에서 할당하는 작업의 단위)
Node.js는 싱글스레드, 논 블로킹 모델로 싱글 스레드가 혼자서 일을 처리하지만 들어오는 요청 순서가 아닌 논 블로킹 방식으로 이전 작업이 완료될 때까지 대기하지 않고 다음 작업을 수행한다.


결론)
노드는 기본적으로 싱글 스레드, 논 블로킹 모델을 채용하므로 I/O 요청이 많이 발생하면 노드를 서버로 사용하는 것이 좋다.
하지만 노드는 CPU 부하가 큰 작업에는 적합하지 않다.

우리가 작성하는 코드는 모두 스레드 하나에서 치리되기 때문에 코드가 CPU 연산을 많이 요구하면 스레드 하나가 혼자서 감당하기 어렵다.

즉, 개수는 많지만 크기는 작은 데이터를 실시간으로 주고받는데 노드는 적합하다. 예를 들어 네트워크나 데이터베이스, 디스크 작업 같은 I/O에 특화되어 있다. 실시간 채팅 애플리케이션, 주식 차트도 포함된다.

결론적으로 노드의 장점은 1) 멀티 스레드 방식에 비해 적은 컴퓨터 자원을 사용한다. 2) I/O 작업이 많은 서버로 적합하다. 3) 웹 서버가 내장되어 있어 별도의 웹서버를 설치할 필요가 없다.
4) 자바스크립트를 사용하기 때문에 JSON 형식과 쉽게 호환된다.
*/

/*
axios GET
get 메서드에는 2가지 상황이 크게 존재한다.

1. 단순 데이터(페이지 요청, 지정된 요청) 요청을 수행할 경우
2. 파라미터 데이터를 포함시키는 경우 (사용자 번호에 따른 조회)
*/

// 모듈? 개발하는 애플리케이션의 크기가 커지면 언젠간 파일을 여러 개로 분리해야 하는 시점이 오는데, 이때 분리된 파일 각각을 '모듈'이라고 한다.
// 모듈은 대개 클래스 하나 혹은 특정한 목적을 가진 복수의 함수로 구성된 라이브러리 하나로 구성된다.

const axios = require('axios'); //node.js 쓸때 모듈 불러오기

axios
  .get('/user?ID=12345')
  .then(function (response) {
    // 성공했을 때
    console.log(response);
  })
  .catch(function (error) {
    // 에러났을 때
    console.log(error);
  })
  .finally(function () {
    // 항상 실행되는 함수
  });

// 옵션을 주고싶을 때 이렇게 요청
axios
  .get('/user', {
    params: {
      ID: 12345,
    },
  })
  .then(function (response) {
    console.log(response);
  })
  .catch(function (error) {
    console.log(error);
  })
  .finally(function () {
    // always executed
  });

// async/await 쓰고 싶다면 async 함수/메소드를 만듦
async function getUser() {
  try {
    const response = await axios.get('/user?ID=12345');
    console.log(response);
  } catch (error) {
    console.error(error);
  }
}
